C51 COMPILER V9.56.0.0   READ_MINIMUM                                                      10/06/2016 22:28:52 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE READ_MINIMUM
OBJECT MODULE PLACED IN ..\Objects\read_minimum.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE read_minimum.c BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\read_minimum.l
                    -st) OBJECT(..\Objects\read_minimum.obj)

line level    source

   1          #include "reg24le1.h" //registers address
   2          #include "stdint.h" //inteiros uint8_t, int8_t, uint16_t....
   3          #include "stdbool.h" //Booleanos
   4          //#include "IIC_app.h" //i2c
   5          #include "intrins.h"
   6          #include "API.h"
   7          #include "nRF-SPIComands.h" //radio commands
   8          
   9          #define MASTER 0X02
  10          #define SLAVE  0x00
  11          
  12          #define READY (W2CON1&0X01)       //if ready ==1,not ready==0
  13          #define ACK   (W2CON1&0X02 )  //1;no ack and 0 ack
  14          #define EN2WIRE()  W2CON0|=0x01;//enable 2 wire
  15          #define DISABLE2WIRE()  W2CON0&=0xFE;
  16          #define STOP()    W2CON0|=0x20;
  17          #define START()   W2CON0|=0x10;
  18          #define FREQSEL(x)  W2CON0|=(x<<2);
  19          #define MODE(x)    W2CON0&=(0xff-0x02);W2CON0|=x;  //master or slave
  20          
  21          
  22          
  23          //Subendere?os usados no sistema
  24          #define MY_SUB_ADDR 0x01
  25          #define OTHER_SUB_ADDR 0x02
  26          //pacote para enviar:
  27          // pacote = [sub_endere?o_destinatario] AXH     AXL     AYH     AYL     AZH     AZL
  28          //Pacote para receber
  29          // pacote = [MY_SUB_ADDR] [COMANDO]
  30          #define Sinal_request_data 0x0A
  31          #define Sinal_LEDS 0x0B
  32          
  33          //EndereÃ§o I2C do sensor em 3.3V
  34          #define MPU_endereco 0x68
  35          
  36          //Pushbuttons
  37          sbit S1  = P0^2;    // 1/0=no/press
  38          sbit S2  = P1^4;    // 1/0=no/press
  39          //LEDS
  40          sbit LED1 = P0^3; // 1/0=light/dark
  41          sbit LED2 = P0^6; // 1/0=light/dark
  42          
  43          //Onde as leituras serÃ£o salvas:
  44          uint8_t readings[6] = {0,5,0,128,0,255};
  45          int i=0;
  46          
  47          void delay_ms(unsigned int x);
  48          void setup_i2c_mpu(void);
  49          void requisitarAccelMPU6050(void);
  50          void enviar_pacote_inercial(void);
  51          void luzes_iniciais(void);
  52          
  53          void I2C_init(void){
  54   1              //IOconfig
C51 COMPILER V9.56.0.0   READ_MINIMUM                                                      10/06/2016 22:28:52 PAGE 2   

  55   1              P1DIR|=0X01;
  56   1              P10=0X01;
  57   1              //ext
  58   1              IEN0|=0X80;
  59   1              IEN0|=0X01;
  60   1              TCON|=0X01;       //ï¿½Â½ï¿½ï¿½Ø´ï¿½ï¿½ï¿½
  61   1              INTEXP|=0x08;     //ï¿½ï¿½P05ï¿½ï¿½ï¿½ï¿½ï¿½Ð¶ï¿½
  62   1              P0DIR|=0X20;      //P05ï¿½ï¿½ï¿½ï¿½
  63   1              P0DIR|=0x40;      //P06ï¿½ï¿½ï¿½ï¿½
  64   1              P05=1;
  65   1              P06=1;
  66   1      
  67   1              //original
  68   1          FREQSEL(2);
  69   1          MODE(MASTER);
  70   1              //NOTE: ja tentei trocar isso pro 0xDF e colocar um  &
  71   1          W2CON1|=0x20;     //ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ðµï¿½ï¿½Ð¶ï¿½
  72   1          W2SADR=0x00;
  73   1          EN2WIRE();        //Ê¹ï¿½ï¿½2-wire
  74   1      }
  75          bool i2c_mpu_writeBytes(uint8_t devAddr, uint8_t regAddr, uint8_t data_len, uint8_t *data_ptr) {
  76   1          bool ack_received;
  77   1              uint8_t numlimit = 0;
  78   1          START();
  79   1          W2DAT=((devAddr+0xa0)<<1)+0;//write
  80   1          if(!ACK){ //IF ACK
  81   2              W2DAT=regAddr;
  82   2          }
  83   1          //BUG: antes isso era um if? ue?
  84   1          while(!ACK && data_len-- > 0) {
  85   2              W2DAT=*data_ptr++ ;
  86   2              numlimit++;
  87   2              if(numlimit==16){
  88   3                  return false;
  89   3              }
  90   2          }
  91   1          ack_received = !ACK;
  92   1          STOP();
  93   1          return ack_received;
  94   1      }
  95          bool i2c_mpu_readBytes(uint8_t devAddr, uint8_t regAddr, uint8_t data_len, uint8_t *data_ptr) {
  96   1          bool ack_received;
  97   1          START();
  98   1          W2DAT=((devAddr+0xa0)<<1)+0;//write from slave
  99   1              if(!ACK){ W2DAT=regAddr;}else{return false; }
 100   1          if(!ACK){ START();}else{return false;}
 101   1      
 102   1          //W2DAT=((devAddr+0xa0)<<1)+1;//read from slave
 103   1          //if(ACK){return false;}
 104   1              tx_buf[0] = MY_SUB_ADDR;
 105   1              i = 1;
 106   1          while(data_len-- > 0 && !ACK)
 107   1          {
 108   2                      //BUG: XXX: O programa esta parando neste laço
 109   2             while(!(W2CON1&0X01)){
 110   3                      LED1 = 1;
 111   3                      }
 112   2                      LED1 = 0;
 113   2                      tx_buf[i] = W2DAT;
 114   2                      i++;
 115   2              //*data_ptr++=W2DAT;
 116   2          }
C51 COMPILER V9.56.0.0   READ_MINIMUM                                                      10/06/2016 22:28:52 PAGE 3   

 117   1              TX_Mode_NOACK(i+1);
 118   1          RX_Mode();
 119   1          ack_received = !ACK;
 120   1          STOP();
 121   1          return ack_received;
 122   1      }
*** WARNING C280 IN LINE 95 OF read_minimum.c: 'data_ptr': unreferenced local variable
 123          void setup(void){
 124   1               // Set up GPIO
 125   1          P0DIR = 0xB7;   // 1011 0111 - 1/0 = In/Out - Output: P0.3 e P0.6
 126   1          P1DIR = 0xFF;   // Tudo input
 127   1          P2DIR = 0xFF;
 128   1          P0CON = 0x00;       // All general I/O
 129   1          P1CON = 0x00;       // All general I/O
 130   1          P2CON = 0x00;       // All general I/O
 131   1      
 132   1              // Radio + SPI setup
 133   1          RFCE = 0;       // Radio chip enable low
 134   1          RFCKEN = 1;     // Radio clk enable
 135   1          RF = 1;
 136   1          rf_init();
 137   1          EA=1; //ativa as interrupï¿½ï¿½es
 138   1          RX_Mode();
 139   1              luzes_iniciais();
 140   1              //I2C_SETUP
 141   1              I2C_init();
 142   1            
 143   1              //Io_config(); //XXX: realmente necessaria
 144   1              //ex_int(); //XXX: realmente necessaria
 145   1              //IIC_init();//initial iic
 146   1              setup_i2c_mpu();
 147   1              //requisitarAccelMPU6050();
 148   1              EA = 1; 
 149   1      }
 150          void main()
 151          {
 152   1          //lÃ³gica:
 153   1          //iniciar i2c
 154   1          //configurar sensores
 155   1          //iniciar rf
 156   1          //Ao se precionar o botÃ£o
 157   1          //  realizar leitura
 158   1          //  despachar leitura
 159   1              setup();
 160   1              while (1) {
 161   2                      if(!S1){
 162   3                              enviar_pacote_inercial();
 163   3                              delay_ms(100); //evita ruidos
 164   3                              while(!S1); //espera soltar o botao
 165   3                              delay_ms(100);
 166   3                      }
 167   2                      if(!S2){
 168   3                              requisitarAccelMPU6050();
 169   3                              delay_ms(100);
 170   3                              while(!S2);//espera soltar o botao
 171   3                              delay_ms(100);
 172   3                      }
 173   2                      if(newPayload){
 174   3                              if(rx_buf[0] == MY_SUB_ADDR){
 175   4                                      switch (rx_buf[1]) {
 176   5                                              case Sinal_request_data:
 177   5                                                      requisitarAccelMPU6050();
C51 COMPILER V9.56.0.0   READ_MINIMUM                                                      10/06/2016 22:28:52 PAGE 4   

 178   5                                                      enviar_pacote_inercial();
 179   5                                                      break;
 180   5                                              case Sinal_LEDS:
 181   5                                                      LED1 = !LED1;
 182   5                                                      LED2 = !LED2;
 183   5                                                      break;
 184   5                                      }
 185   4                              }
 186   3                              newPayload = 0;
 187   3                              sta = 0;
 188   3                      }
 189   2              }
 190   1      }
 191          /**************************************************/
 192          void delay_ms(unsigned int x)
 193          {
 194   1          unsigned int i,j;
 195   1          i=0;
 196   1          for(i=0;i<x;i++)
 197   1          {
 198   2             j=508;
 199   2                 ;
 200   2             while(j--);
 201   2          }
 202   1      }
 203          /**************************************************/
 204          void luzes_iniciais(void){
 205   1              LED1 = 1; LED2 = 0;
 206   1              delay_ms(1000);
 207   1              LED1 = 0; LED2 = 1;
 208   1              delay_ms(1000);
 209   1              LED1 = 1; LED2 = 1;
 210   1              delay_ms(1000);
 211   1              LED1 = 0; LED2 = 0;
 212   1      }
 213          /**************************************************/
 214          /************MPU**********************************/
 215          void setup_i2c_mpu(void){
 216   1          //iniciar i2c
 217   1          //Set the register Power Management to start
 218   1              uint8_t ligar_mpu = 0x00;
 219   1              i2c_mpu_writeBytes(MPU_endereco, 0x6B,1, &ligar_mpu);
 220   1      }
 221          
 222          void requisitarAccelMPU6050(void){
 223   1          //Ler 6 bytes a partir de 0x3B
 224   1          //Sendo esses:
 225   1          // [ACCEL_XOUT_H] [ACCEL_XOUT_L]
 226   1          // [ACCEL_YOUT_H] [ACCEL_YOUT_L]
 227   1          // [ACCEL_ZOUT_H] [ACCEL_ZOUT_L]
 228   1              LED2 = i2c_mpu_readBytes(MPU_endereco,0x3B, 6,readings);
 229   1      }
 230          
 231          void enviar_pacote_inercial(void){
 232   1          LED2 = 1;
 233   1          tx_buf[0] = MY_SUB_ADDR;
 234   1          for(i=1;i<7;i++){
 235   2              tx_buf[i] = readings[i-1];
 236   2          }
 237   1          //enviando e retornando ao padrao:
 238   1          TX_Mode_NOACK(7);
 239   1          RX_Mode();
C51 COMPILER V9.56.0.0   READ_MINIMUM                                                      10/06/2016 22:28:52 PAGE 5   

 240   1              LED2 = 0;
 241   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    924    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     69      25
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
